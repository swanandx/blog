[{"content":"What is in this post? You might have seen something like \u0026ldquo;Product Keys\u0026rdquo; for some softwares or some other applications, but how exactly do they verify if the key is correct ? They implement a function that will validate key. We will be reverse engineering a binary, which validates a key using some function, and then we will write a key generator, i.e key-gen, for it to generate valid keys.\nKey checker binary We got a binary that validates our key :\nmain function Lets decompile it using ghidra and look at main function :\nAs we can see, it scans key using scanf and then pass it to validate_key function. Before going ahead, lets see what is the first argument of scanf :\nSo the binary is using scanf(\u0026quot;%d\u0026quot;,\u0026amp;local_14), by this we can say that key will be integer. Now, looking at validate_key function.\nvalidate_key function Here, it will return true if our key is perfectly divisible by 0x4c7 which is 1223 in decimal. Therefore, any number divisible by 1223 is a valid key. Lets verify this :\n As you can see, -1223 is also a valid key, as in the end remainder is 0.\n Now we know the logic, lets write a key generator for this.\nWriting key-gen From the analysis, we know the following:\n Key is a integer. It should be divisible by 1223.  Therefore, we can say, key can range from -2147483647 to 2147483648 as per INT_MIN and INT_MAX in C. But as our key has to be divisible by 1223, our range become -2147482822 to 2147482822,as they are smallest and largest multiple of 1223 in our range.\nMAX_INT = 2147482822 MIN_INT = -2147482822 Then, we generate a random integer in that range by using random\nimport random random_number = random.randint(MIN_INT,MAX_INT) Now, we have a random integer, but we need it to be divisible by 1223. So, we divide the random number by 1223 and then subtract the remainder from it.\nkey = random_number - (random_number % 1223) So, final script becomes,\nimport random MAX_INT = 2147482822 MIN_INT = -2147482822 random_number = random.randint(MIN_INT,MAX_INT) key = random_number - (random_number % 1223) print(key) Lets execute it, and see if it generates valid keys.\nWe did it!! We successfully wrote a key generator that generates valid keys!!\n NOTE : we didn\u0026rsquo;t have any restrictions on length of key, but if there was any, like key length must be 12, then we can just prepend the generated key with 0s till it\u0026rsquo;s length is 12. For example,  Try it yourself! What are you waiting for? Compile some binaries and try to write key-gen for it. This will help you in understanding and will improve scripting skills too.\n","permalink":"https://swanandx.github.io/blog/posts/re/keygen/","summary":"What is in this post? You might have seen something like \u0026ldquo;Product Keys\u0026rdquo; for some softwares or some other applications, but how exactly do they verify if the key is correct ? They implement a function that will validate key. We will be reverse engineering a binary, which validates a key using some function, and then we will write a key generator, i.e key-gen, for it to generate valid keys.","title":"Reversing Binaries: Key generators"},{"content":"What is this about? I saw a lot of people struggling to solve easy reverse engineering (RE) challenges (me too when I was just starting), well, I am not saying I am great at it now, but have really improved my skills so that now I can solve many RE challenges in ctfs. That is why, I am writing this blog, hoping it will help at least a few people.\nBut what is in RE challenges? Basically, in RE challenges, you will be getting an application or executable, of which, we have to find the correct input which will lead to desired output by doing reverse engineering, end goal is to get the flag. I mostly saw the following types of executables:\n Password checker - This will take password as input, and will print flag if password is correct. Flag checker - This will take the flag as input and check if it is correct.  So I got binary in the challenge, now what? We have to basically find the flag , which can be in different formats like THM{}, ictf{}, etc. or just digits, really depending on the challenge.\nI get it, but how? Here is my simple methodology, or path, for solving it.\n You can use radare2 / gdb instead of Ghidra for static analysis too if you are familiar and comfortable with assembly.\n I will elaborate why I choose to do it like that later in the blog.\nstrings strings is very useful yet so simple command.\nAs per manual, it prints the printable characters in a file. So why it is helpful? Well, if the flag is present as printable characters, we can find it straight away. Here is example, suppose I have a binary rev_me\nI ran strings rev_me and found the password and flag :)\nHere is proof,\n.\n why start with strings ? \u0026ndash;\u0026gt; You will find a lot of challenges that can be solved using this single command. If you just run it and found the flag, it will save a lot of your precious time.   NOTE: strings command is also very helpful in malware analysis, check out John Hammond malware analysis videos on YouTube or MAL:strings room on TryHackMe for that.\n ltrace Now what if flag was not in strings? Next place is to trace library calls such as strcmp() if they are being used, we do it by ltrace.\nSyntax is ltrace /path/to/binary It will show the library calls being used like:\n... strcmp('idk','p@ssw0rd') ...  IMP : I did not show example as now-a-days, ltrace is not able to trace calls due to the way in which gcc compiles program. But it still can be useful in ctfs. It only takes 2 sec. to do it, so, always give it a try, we never know.\n  Now lets begin some real cool stuff. Let me first elaborate why I divided challenges in two categories in beginning.\n Password checker This binaries have work flow like:\n1. Take input -\u0026gt; 2. check if input matches the password -\u0026gt; 3. print flag if it matches. Our main goal is to get flag, so instead of figuring out password, we directly jump to code where it prints the flag.\nFor example, I have a binary which prints flag if password is correct. Let us use gdb\nAs you can see, I disassembled the main function. In the main function\nwe are looking for cmp here. we can see it at \u0026lt;+103\u0026gt; . It compares 2 values and if they are equal, it jumps to \u0026lt;main+129\u0026gt;. We can tell that the code at \u0026lt;main+129\u0026gt; prints the flag as it is called if compare is successful, so let\u0026rsquo;s set a breakpoint just after it takes input, i.e. \u0026lt;main+68\u0026gt; and then run it.\nwe supply it with any random password, as we are just going to skip the check anyway. Now, lets jump to \u0026lt;main+129\u0026gt; and see what happens.\nWe successfully got the flag!!\n IMP: same can be done using radare2. instead of jump, use dr rip={address to jump} and then continue it, rest procedure is similar.\n Flag checker Now what if the flag itself is the password? work flow is like\nTake flag as input -\u0026gt; check if it is correct. Now, no use of bypassing the check, as our goal is to get the flag. So how to do it? Let us say we have binary called rev like:\nSo, in order to find flag, I used Ghidra. Open ghidra, create new project and then import the binary.\n You can learn about ghidra more from CC:Ghidra room on TryHackMe or there are many tutorials available for it.\n After analyzing binary, I checked the pseudo code generated by ghidra.\nIn main function, you can see it is xoring every character with 5 and then adding 5 to it , then it is comparing result with flag.\nLet\u0026rsquo;s check what is in flag and take note of those values.\nNow, we know what the result is, let\u0026rsquo;s find what leads to it, for that, write a script that will take character from result then subtract 5 and then xor against 5. We are doing the operations it did to our input in reverse order.\n NOTE: If you wonder why it looks so complicated, well , that is just how ghidra works. Try compiling own binaries and then reversing it to see how ghidra is generating the code.\n flag_bytes = [0x48, 0x4e, 0x49, 0x47, 0x83, 0x82, 0x3a, 0x7c, 0x5f, 0x82, 0x6f, 0x7c, 0x5f, 0x82, 0x3a, 0x7c, 0x7d] flag = \u0026#34;\u0026#34; for x in flag_bytes: flag += chr((x - 5)^5) print(flag) Executing the python script gives the flag!\nLet\u0026rsquo;s verify the flag  IMP : You could have solved the other challenges using ghidra, as it gives the pseudo code which is very helpful. It might be wrong sometimes though. I preferred to use Ghidra in end as it is resource heavy, but if you have resources, you can run it right away.\n What if challenge is not linux executable?  For .NET assembly use ilspy or some other .NET decompiler For .apk, There are a few steps here with different tools, but I just search for online apk decompiler on Google and use online tools. You can also decompile .exe binaries using ghidra.  Wicked cool tricks This are some tricks that I developed through practice\n If you see hex numbers getting assigned to variables in ghidra or something, always look their ASCII value. That might be the flag or password just in front of you. A lot of .java files after decompiling .apk? Suppose flag format is flag{}, just go in directory where there are all .java files and run cat *.java | grep flag{ or you can also try something like grep -iRl flag{. For first time, loops in pseudo code generated by ghidra might look complicated as there are pointers **(int)((long)local28 + 4), don\u0026rsquo;t worry about that much, just focus on our goal and understanding the flow. If there is no main function, look entry function, usually first function called there is __libc_start_main and the first argument to it is usually the main function. If binary prints like wrong, give flag or something, look at which function is responsible for it, that is most probably the main function. I suggest compile some binaries on own and look at how ghidra is generating pseudo code. This will be very helpful in understanding. You can use angr. It is a python framework for analyzing binaries. Check out videos and tutorials for it. I am sure it will worth it.  What next? TL;DR - practice!!\nWe just barely scratched surface of reverse engineering. This is just like a methodology, you need to practice a lot if you want to master it. Different ways of solving challenge, looking at assembly and pseudo code, where to look for flags and what might be rabbit hole etc.\nDo not worry if you think like you are not getting what application is doing or not able to solve challenges, it all comes with practice. There are many awesome resources and many lists of them you can find online, use them to learn more and keep practicing.\n","permalink":"https://swanandx.github.io/blog/posts/re/ctfs/","summary":"What is this about? I saw a lot of people struggling to solve easy reverse engineering (RE) challenges (me too when I was just starting), well, I am not saying I am great at it now, but have really improved my skills so that now I can solve many RE challenges in ctfs. That is why, I am writing this blog, hoping it will help at least a few people.","title":"Reversing Binaries: CTF Edition"}]